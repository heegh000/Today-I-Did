### 융합세미나

이번 학기 마지막 시험이 끝났다.

관심있는 분야도 있었고, 그렇지 않은 분야도 있었지만 나름 열심히 공부했다.

호랑이는 토끼를 잡을 때도 최선을 다한다.

### 라인트레이서

2022년 6월 중순, 학교에서 공부중이던 나는, 4학년이 된 후배들이 기계를 가지고 무언가 하고 있는 모습을 보았다. 그게 뭐냐고 물어보니 임베디드 과제라고 하였다. 그 친구들이 고통받고 있는 모습을 보고 있자니 내 심장은 뛰었고, 4학년이 되면 꼭 임베디드를 들으리라 결심한 순간이었다.

그렇게 3학년 2학기를 지나, 4학년이 되어 임베디드를 신청하였다. 처음 트랙이 공개되었을 때, 마프 수업을 들은 친구가 ‘트랙이 쉬워졌는데?’라고 한 말에 실망하기도 하였다. 마프때의 트랙과는 다른 어려움이 있을 줄도 모른 채 말이다. 

처음 기기를 받았을 때, 이름도 지우주고 의욕도 넘쳐흘렸다. 하지만 과제를 시작하자 당황을 금치 못했다. 기기의 상태가 정말 이상했기 때문이다. 내 코드가 문제인지, 기기가 문제인지 알지 못하니 미쳐버릴 것 같았다. 아무리 생각해도 코드에는 이상이 없는 것 같아서 기기를 교체했더니 잘 움직였다. 

두 번째 기기를 받고 본격적으로 과제를 하기 위해, 내 돈으로 트랙도 출력하고, 건전지도 구매했다. 초기에는 직진과 90도 회전을 완벽하게 하는 것을 목표로 잡았다. 그때의 나는 그것들이 얼마나 어려운 지 알지 못했었다. 

이 기기는 양쪽 모터의 속도가 다른데다가 배터리의 잔량에 따라서도 속도가 달라진다. 물론 배터리의 잔량을 알 수 있는 방법따윈 없다. 이러한 특징들은 완벽한 직진과 90도 회전을 불가능하게 했다. 87도 회전을 하며, 직진을 하다가 트랙을 벗어나기 일쑤였다. 열심히 수치를 세부조정하여도 얼마 뒤면 배터리 잔량이 달라져서 안맞곤 했다. 이러한 불완전한 직진과 회전은 단순히 트랙을 벗어나는 것뿐만 아니라, 분기 인식에도 큰 문제를 줬다. 

엎친데 덮친격으로 두 번째 기기의 센서 부분에 이상이 생겨서 월요일에 세 번째 기기로 교체하기로 하였다. 기기를 쓸 수 없는 동안은 경로 최적화 알고리즘에 대해 고민했다. 처음에는 스택을 잘만 사용하면 금방 해결법을 찾을 수 있을 줄 알았다. 하지만 이 기기로는 거리를 측정할 수 없기때문에, 오직 분기와 코너만을 인식해서 최적화해야만 했다. 새벽 4시까지 고민도 해보고, 구글에서 LSRB 알고리즘 등도 찾아봤지만 뾰족한 수는 나오지 않았다. 결국 내가 만든 반례는 거리를 측정해야만 해결할 수 있다는 것을 깨닫고, 타협하여 LSRB 알고리즘을 채택하기로 결정했다. LSRB 알고리즘 자체는 스택만 활용하면 바로 구현 가능했기 때문에 큰 어려움은 없었다. 진짜 문제는 이 기기의 움직임을 컨트롤하는 것이었다.

그 후로는 사실 계속 기기와의 싸움이었다. 직진에서의 보정 알고리즘, 90도 회전, 코너 및 분기 인식, 180도 회전 인식어려웠던 점이 한 두개가 아니였다. 하나를 수정하면 다른 알고리즘에도 영향을 미쳐 다시 수정하고 수정하고 수정하고의 반복이었다. 

먼저 보정 알고리즘에 대해 이야기 하자면, 이 기기는 정확히 직선으로 갈 수가 없다. 왼쪽 바퀴와 오른쪽 바퀴의 속도가 다르기 때문이다. 아무리 미세하게 수치를 다르게 주더라도, 정확히 90도 회전을 할 수 없기 때문에 반드시 필요했다. 처음에는 나간 쪽 바퀴의 속도를 조금씩 높여줘보기도 하고, 나간쪽 바퀴를 반대로 돌려보기도 하였는데, 분기나 코너 근처에서 보정을 시작하는 경우 문제가 많았다. 답답함에 편의점을 가던 중, 자동차들이 주차를 할 때 후진과 직진을 반복하는 것에서 영감을 얻어, 양쪽 바퀴 속도를 다르게 하면서 후진을 통해 보정하는 알고리즘을 짰고, 나름 만족스러워서 결국 끝까지 이 알고리즘을 채용했다.

다음으로는 나를 가장 괴롭혔던 회전이다. 이 기기는 배터리 잔량에 따라 모터의 속도가 달라진다. 즉 똑같은 속도, 똑같은 딜레이를 주더라도 배터리가 많으면 더 많이 돌고, 배터리가 적으면 더 조금 돈다는 말이다. 정확히 90도씩 돌도록 왼쪽, 오른쪽 바퀴의 속도를 정하고, 다르게 딜레이를 적용하더라도, 잠시 뒤면 무용지물이 되버린다. 이러한 사실을 깨닫고 나는 센서를 기반으로 한 회전을 구현하기로 결심했다. 하지만 이 역시도 쉽지 않았다. 이 기기가 비스듬히 회전을 시작하는 경우나, 연속해서 회전을 해야 하는 경우 트랙을 벗어나기 일쑤였다. 고민을 하다가 결국 가운데 센서(4번, 3번)만 검정색이 될때까지 회전을 하는 것으로 코드를 수정했고 마음에 들지 않았지만 직진에서의 보정을 믿기로 결심했다. 지금 생각해보면 신의 한수였던 것 같다. ‘배터리의 잔량에 따라 달라지는 모터를 믿지 않고, 센서를 기반으로 최대한 90도에 가깝게 돌리되, 오차가 생긴 것은 직진에서의 보정으로 해결한다.’ 어떻게 보면 정해에 가까운 답같아 보이고 글이라서 안느껴질지 모르겠지만, 최대한 90도에 가깝게 회전하기 위해, 언제까지 회전을 해야 하고 어떤 센서 상태에서 멈춰야 할지를 정하기까지 정말 많은 시간과 노력을 들였다.

다음으로는 코너 및 분기 인식이다. 나는 Phase 1에서 Left Hand on Wall을 채용했기 때문에 T자형 분기에서 왼쪽부터 가야만 한다. 당연히 쉽게 생각하면 if else 문을 통해 좌회전을 먼저 인식하도록 하면 된다. 하지만 이 기기는 비스듬히 T자형 분기에 도착할 수도 있다. 그래서 일부러 딜레이를 줘서 잠시후 다시 읽어봐야 한다. 사실 이게 어려웠던 것은 아니다. 가장 큰 문제는 바로 이 기기의 센서와 바퀴의 축이 일치하지 않는다는 것이다. 바퀴 축 앞에 센서가 있기 때문에 인식하자마자 돌면 트랙의 라인에 그대로 서지 않는다. 코너 및 분기를 인식하고 잠시 앞으로 간 뒤에 회전해야 한다. 문제는, 계속 언급하지만, 배터리 잔량에 따른 모터의 속도이다. 앞으로 얼마나 더 가야할지를 수치로 조정해봐야 소용없다. 따라서 센서를 기반으로 흰색을 만날 때까지 전진하기로 결심했고, 이는 정말정말 잘한 판단이었다고 생각한다. 물론 그 과정에서 가운데 센서 2개만 보는 것이 아니라, 좌회전, 우회전에 따라 다르게 6번, 5번센서 혹은 2번, 1번 센서를 봐야 했지만 말이다. 

다음은 180도 회전 인식이다. 4번 혹은 3번 센서가 흰색이 되면 보정 알고리즘이 작동한다. 180도 회전은 4번과 3번이 동시에 흰색이 되면 작동한다. 근데 문제는, 이 기기가 비스듬히 가다보면 4번과 3번이 동시에 흰색이 된 것을 감지하는 것이 아니라 한 쪽만 흰색이 되었다고 감지하여 보정알고리즘을 무한히 시행한다는 점이었다. 처음에는 이걸 해결하려고 무한 루프 탈출도 구현해보고, 보정을 더 빡세게 하는 방법도 해봤지만 신통치 않았다. 결국 이 문제도, 4번 혹은 3번이 나가면 잠시 딜레이를 둔 후 다시 보는 방법을 사용했는데, 이러한 생각을 했다는 사실이 만족스러웠다.

마지막으로 소소하게 나를 괴롭혔던 문제로는 endpoint 인식이라던가, 보정을 후진으로 하다보니 LSRB 알고리즘을 위해 분기를 저장해나가는 과정에서 같은 분기를 여러번 인식한다거나 하는 문제가 있었지만, 종종 발생하던 문제였고 간단히 if문을 추가해서 해결했다.

위의 같은 문제들을 모두 해결하는데까지 정말정말 오랜시간이 걸리고 힘들었다. 그래도 모두 해결하고나니 얼추 기기는 처음부터 끝까지 Left Hand on Wall로 잘 갔다.

나머지는 크게 어려움이 없었다. Phase 1때는 분기를 인식하면 Left Hand on Wall에 따라 움직이고 그때의 선택을 저장한다. Phase 2를 시작하기 전 저장된 분기를 바탕으로 LSRB 알고리즘으로 최적화를 한다. Phase 2때는 분기를 인식하면 Left Hand on Wall을 따르는 것이 아니라, 최적화된 경로를 통해 움직이게 만들었다.

처음 Phase 1, 2를 모두 통과했을 때 얼마나 기뻤는지 모른다. 불안불안한, 자잘한 문제들도 있었지만 금방 해결할 수 있었다. 해결하고 조교님께 통과 판정을 받았을 땐 너무 후련하고, 함께한 기기가 너무 자랑스러웠다. 분명 몇 주째 이 기기에 대한 분노만 있었는데 말이다. 

돌이켜보면 처음부터 정말 많은 시도를 하였다. 처음에는 이론적으로 완벽한데, 제대로 돌아가지 않는 기기를 보며 화도 많이 났다. 왼쪽, 오른쪽 바퀴 속도가 다른건 감안하더라도, 돌릴 때마다 속도가 달라지는 것은 해결하기 어려웠다. 왜냐하면 바퀴의 속도뿐만 아니라 회전에서의 딜레이, 직진에서의 들레이 등을 계속 수정해줘야 했기 때문이다. 결국 바퀴의 속도를 제외한 미세한 수치 조정을 포기하고 센서에 최대한 의존하여 기기를 컨트롤한 방향을 잡은 것이 해답이었다. 특히 센서를 읽자마자 바로 결정하는 것이 아니라, 조금 텀을 주고 다시 읽어서 결정하는 것이 핵심이었다고 생각한다. 이렇게 구현하니, Phase 1, 2에서 똑같은 코드로 구현하되 분기에서의 처리만 다르게 해주면 되었다. 센서에 최대한 의존 + 분기인식 시 Phase 1, 2에 따라 다른 행동이 내가 내린 해답이었다.

결국 한 달동안 나를 괴롭히던 라인트레이서가 끝났다. 이 과제는 DB, OS와 다른 어려움이 있었고, 그만큼 나는 많은 성장을 하였다. 내가 이 과제를 통해 배운 것은, 인내심과 주어진 상황을 고려하면서 문제를 해결하는 능력이다. 

DB, OS에서는 문제를 해결하기 위해 나만의 디자인을 고민하고 적용하는 과정을 배웠다면, 라인트레이서에서는 나의 디자인을 주어진 상황에 맞게끔 타협하고 수정하여 적용하는 과정을 배웠다. DB, OS의 어려운 과제를 하면서 문제 해결 능력을 기른 것처럼, 라인트레이서 과제를 통해서도 큰 도약을 하였다고 생각한다. 

현실과 이론은 다르다는 것을 깨닫고, 현재 이 기기에서 가능한 구현이 무엇인지를 생각해보고, 선택하면서 테스트하고, 좌절하는 과정이 정말정말 힘들고 고통스러웠지만, 결국 해냈을 때의, 내 구현이 틀리지 않았다는 것을 확인한 순간의 쾌락은 짜릿하다. 내가 어려운 과제가 있는 과목들을 골라 듣는 이유도 이것이다.  

라인트레이서 과제, 그리고 론티야. 덕분에 4학년 1학기가 즐거웠다!

---

### 오늘의 나

드디어 종강이다.

종강하고 집에 갈 때면 많은 생각이 든다.

내일은 집에서 쉬면서 종강 회고록을 적어야겠다.
